---
title: "OIDC完全に理解した"
emoji: "🔑"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["認証", "認可", "OIDC"]
published: false
---

:::message
本記事では、OAuth 2.0 を OAuth、OpenID Connect 1.0 を OIDC と表記するため、適宜読み替えていただけますと幸いです。
:::

# TL;DR

# はじめに
こんにちは、レバテック開発部レバテックプラットフォーム開発チームの内藤です。

最近、弊チームでは認証・認可の勉強会を実施しました。
内容としては、ネットの記事や、認証認可の世界ではお馴染みの[OAuth屋](https://twitter.com/authyasan)さんの本を適宜議論を挟みながら読むといったものです。

読んだ本は以下に載せておくので興味ある人は是非お手に取ってみてください！（技術書にしてはビビるぐらいに安いです）

https://authya.booth.pm/items/1296585
https://authya.booth.pm/items/1550861
https://authya.booth.pm/items/1877818

先日、この勉強会に際し、弊チームのかにさんが **OAuth** についての記事を公開しました。
https://zenn.dev/levtech/articles/a6e8910df5baa0

今回はそれに続いて、僕が **OIDC** について整理していくので、最後までお付き合いいただけると幸いです！

# 基礎編
## とは？
2007年に米国で設立された非営利の国際標準化団体[OpenID Foundation(OIDF)](https://openid.net/)の公認団体である[OpenID Foundation Japan](https://www.openid.or.jp/)によれば以下のように説明されています。（[参考](https://openid-foundation-japan.github.io/openid-connect-core-1_0.ja.html)）

> OpenID Connect 1.0 は, OAuth 2.0 [RFC6749] プロトコルの上にシンプルなアイデンティティレイヤーを付与したものである. このプロトコルは Client が Authorization Server の認証結果に基づいて End-User のアイデンティティを検証可能にする. また同時に End-User の必要最低限のプロフィール情報を, 相互運用可能かつ RESTful な形で取得することも可能にする.

こちらの説明でも分かる通り、OIDC は OAuth をベースとした仕組みなので、OAuth についても補足しておくと、 [OpenID Foundation Japan](https://www.openid.or.jp/) によれば以下のように説明されています。（[参考](https://openid-foundation-japan.github.io/rfc6749.ja.html)）
> OAuth 2.0 は, サードパーティーアプリケーションによるHTTPサービスへの限定的なアクセスを可能にする認可フレームワークである. サードパーティーアプリケーションによるアクセス権の取得には, リソースオーナーとHTTPサービスの間で同意のためのインタラクションを伴う場合もあるが, サードパーティーアプリケーション自身が自らの権限においてアクセスを許可する場合もある.

つまり、OIDC は OAuth をベースにして、**認可だけでなく認証も行えるようにした拡張仕様**と言えます。

例えば、Google ログイン機能を作成する際に OIDC を利用します。OIDC を利用することで、Google や Facebook などの認証プロバイダーを介して安全にユーザーを認証し、プロフィール情報を取得できます。

:::details 【コラム】OAuth を認証に使ってはいけない？
話は少し逸れますが、上記の説明を受けて、「OAuth を認証に使ってはいけないのか？」と疑問に思われる方もいるかもしれません。
実際、多くの記事で OAuth を認証用途に使うべきではないという意見が散見されます。

しかし正確には「**一部のOAuth認可フローを認証に使うとセキュリティーホールが発生するため、認証に使ってはいけない**」というのが正しい理解になります。
OAuth には様々な認可フローがありますが、セキュリティーが問題視されているのは、ブラウザーベースのアプリケーションで用いられがちな**インプリシットグラント**です。

インプリシットグラントでは、ブラウザー経由でアクセストークンが直接クライアントに渡され、第三者による悪意あるアクセスの可能性が高まるため、セキュリティー上良くないとされています。

[//]: # (Todo: p.20あたりの図や説明をまとめる)

では、認可コードグラントはどうでしょうか？
認可コードの場合、8, 9 番で入れ替えられるのは、認可コードです。


[//]: # (Todo: p.20あたりの図や説明をまとめる)


:::

## OIDCの登場人物
OIDC には以下 4 つのロールが定義されています。

- **エンドユーザー**
  ブログアプリケーションにアクセスし、コンテンツを作成・閲覧しようとするユーザーです。エンドユーザーは、ブログアプリケーションを使用するために Google や Facebook などの ID プロバイダを介して認証を行います。
- **リライング・パーティー (Relying Party, RP)**
  エンドユーザーの認証情報を用いて、保護されたリソースにアクセスしようとするアプリケーションです。この場合、シンプルなブログアプリケーション自体がリライング・パーティーに該当します。ブログアプリケーションは、ID プロバイダからエンドユーザーの認証情報を取得し、その情報を基にユーザーのアカウント管理やアクセス制御を行います。
- **IDプロバイダ (Identity Provider, IdP)**
  エンドユーザーの認証を行い、その情報をリライング・パーティーに提供するサーバーです。この場合、Google や Facebook などの認証プロバイダが ID プロバイダに該当します。ID プロバイダは、エンドユーザーのアイデンティティを確認し、認証トークンを発行します。
- **UserInfo エンドポイント**
  エンドユーザーの詳細なプロフィール情報を提供するエンドポイントです。ブログアプリケーションの例では、Google や Facebook の UserInfo エンドポイントが該当します。ブログアプリケーションはこのエンドポイントを使用して、エンドユーザーに関する追加情報（例えば、名前やメールアドレスなど）を取得し、ユーザープロファイルを構築します。

## OIDCのフロー
OIDC には、以下の 3 つの主要なフローがあります。

### 認可コードフロー
- 特徴
  - クライアントが認可コードを受け取り、それをバックエンドサーバーに渡してアクセストークンと ID トークンを取得するので、トークンが流出するリスクが低く、セキュア
- ユースケース
  - バックエンドサーバーを持ち、コンフィデンシャルクライアントであるアプリケーション

#### 認可コードの取得
1. OIDC 開始
エンドユーザーが「Google アカウントでログイン」ボタンを押下することにより、OIDC が開始します。
リライング・パーティーは OIDC 開始のリクエストを受け付けると、HTTP 302 を返却し、ID プロバイダが提供する**認証エンドポイント**へリダイレクトさせます。
このリクエストを**認証リクエスト**と呼び、以下のようなクエリパラメータが設定されています。

```text
GET /authorize?
    &response_type=code
    &client_id=YOUR_CLIENT_ID
    &redirect_uri=YOUR_REDIRECT_URL
    &scope=openid+email+profile+offline_access+model.request+model.read+organization.read+organization.write
    &state=XXXXXXXXXXXXXXXXXXX
    &nonce

HTTP/1.1
Host: accounts.google.com
```

| パラメータ         | 説明                                                                |
|---------------|-------------------------------------------------------------------|
| response_type | ここでは認可コード（`code`）を要求していることを示します。                                  |
| client_id     | OIDCプロバイダーから発行されるアプリケーションを識別するための一意のID。                           |
| redirect_uri  | 認証が成功した後にユーザーがリダイレクトされるURL。                                       |
| scope         | 要求するスコープ。OIDCの`openid`、`email`、`profile`に加え、その他のリソースへのアクセス権を指定する。 |
| state         | CSRF攻撃を防ぐためのランダムな文字列。認証リクエストとそのレスポンスを関連付けるために利用する。                |
| nonce         | リプレイ攻撃を防ぐためのランダムな文字列。認証リクエストと対応するIDリクエストであることを保証する。               |


2. ユーザー認証


3. ユーザー情報の開示に同意

### インプリシットフロー
- 特徴
  - クライアントは認可サーバーから直接 ID トークンとアクセストークンを受け取るため、認可コードのステップがなく、シンプル
- ユースケース
  - バックエンドサーバーを持たないアプリケーション
  - SPA 構成のアプリケーション

### ハイブリッドフロー
- 特徴
  - 認可コードフローとインプリシットフローのハイブリッドなフロー
- ユースケース
  - バックエンドサーバーを持ち、パブリッククライアントとコンフィデンシャルクライアントの両方で構成されるアプリケーション

OIDC ではこれらのフローを response_type を基にして切り替えます。


## OIDCの特徴
OIDC は、ユーザー認証を目的として設計されており、OAuth に比べユーザー認証に関するセキュリティーが強化されています。 

OIDC と OAuth の関係を一言で言うと、以下のような式で書くことが出来ます。

```text
OIDC = OAuth + IDトークン + UserInfoエンドポイント
```

**ID トークン**と **UserInfo エンドポイント**について、それぞれ説明していきます。

### IDトークン
ID トークンは、ユーザーの認証情報を含む署名付きの JWT（JSON Web Token）で、OIDC では ID トークンによってエンドユーザーの認証を行います。JWT は [RFC 7519](https://datatracker.ietf.org/doc/html/rfc7519) で規定されており、セキュリティとデータ整合性を確保するために広く使用されています。

JWTは以下の3つの部分から構成されています。

1. **ヘッダー**
2. **ペイロード**
3. **署名**

#### ヘッダー

ヘッダーには、以下の情報が含まれます。

- **typ（トークンのタイプ）**
    - 例: `"JWT"`
- **alg（署名アルゴリズム）**
    - 例: `"HS256"`（HMAC SHA256）

#### ペイロード

ペイロードには、以下のようなトークンに関する情報が含まれます。

- **iss（トークンを発行した認証サーバーの識別子）**
    - 例: `"https://auth.example.com"`
- **sub（ユーザーの一意の識別子）**
    - 例: `"1234567890"`
- **aud（トークンの受け取り手、通常はクライアントID）**
    - 例: `"my_client_id"`
- **exp（トークンの有効期限）**
    - 例: `1622563200`（Unix時間）
- **iat（トークンの発行時刻）**
    - 例: `1622476800`（Unix時間）

#### 署名

署名は、これまで説明した「ヘッダー」+「.」+「ペイロード」をBase64URLエンコードしたもので、これによりトークンの改ざん防止と発行者の信頼性が保証されます。

これらの内容が実際のJWTに含まれているかは、[[番外編] 実際のサービスでJWTの中身を覗いてみよう]()で検証しています。気になる方はぜひそちらも覗いてみてください！

### ユーザー情報の取得
OpenID Connect (OIDC) において、クライアントアプリケーションはユーザーのプロフィール情報や認証情報を取得するために、ユーザー情報エンドポイントにアクセスします。

#### ユーザー情報リクエストの流れ
1. **アクセストークンの取得**
クライアントアプリケーションは、認可サーバーが発行する特定のリソースにアクセスする権限を持つアクセストークンを取得します。

2. **ユーザー情報エンドポイントへのリクエスト**
クライアントアプリケーションは、取得したアクセストークンを使用してユーザー情報エンドポイントにリクエストを送信します。このリクエストは一般的にHTTP GETメソッドを使用します。

    ```http
    GET /userinfo HTTP/1.1
    Host: auth.example.com
    Authorization: Bearer {access_token}
    ```

3. **ユーザー情報の取得**
認可サーバーは、アクセストークンの有効性を確認し、有効であればユーザー情報をJSON形式で返します。
  
    ```json
    {
        "sub": "1234567890",
        "name": "John Doe",
        "email": "john.doe@example.com",
        "preferred_username": "johndoe",
        "given_name": "John",
        "family_name": "Doe"
    }
    ```


# 実践編
## ALBでOIDCを使用して、ユーザを認証する方法
## GitHubActionsでOIDCを使用して、AWS認証を行う方法

# おわりに

# 参考記事
https://authya.booth.pm/items/1296585
https://authya.booth.pm/items/1550861
https://authya.booth.pm/items/1877818
https://www.sakimura.org/2012/02/1487/
