---
title: "君たちの知らないAPIの話をしよう"
emoji: "👺"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["API", "APIデザインパターン"]
published: false
publication_name: "levtech"
---

# TL;DR


# はじめに
現代のソフトウェア開発において、API設計は非常に重要な要素です。API設計は、アプリケーションの機能性、保守性に深く関わっています。

「**APIデザインパターン**」は、この重要かつ複雑な分野において、非常に価値のある一冊です。

https://techplay.jp/book/373

APIの設計は、表面上は単純なように思えるかもしれませんが、その背後には実行可能でありながら表現力があり、シンプルで予測可能なインターフェースを提供することが求められます。しかし、実際にこれらの原則を適用しようとした場合、単純な標準メソッドだけでは限界があります。

そこで「APIデザインパターン」の価値が際立ちます。この本は、API設計の課題を克服するための具体的な手法とデザインパターンを詳述しています。カスタムメソッド、ロングランオペレーション、再実行可能ジョブなど、多様なデザインパターンが紹介されており、これらはAPIの基本原則に忠実でありながら、より複雑な要件や特有の問題に対処するために考案されています。

この記事を通じて、一部のAPIのデザインパターンを咀嚼し、実際のプロジェクトで適用するイメージを掴んでいただけたら嬉しいです。

# そもそも良いAPIとは？
![良いAPIとは？](/images/talk_about_apis_you_dont_know_about/good_api.png)

## Executable -実行可能であること-
APIの設計において最も基本的かつ重要な要素は「**実行可能性**」です。これは、システムがユーザーが行いたいことを実際に遂行できる能力を持つことを意味します。

実行可能なシステムは、ユーザーの要求を満たすだけでなく、迅速かつ正確な結果を提供することで、信頼性とユーザーエクスペリエンスを高めます。

## Expressive -表現力があること-
良いAPIは、実行可能性に加えて高い「**表現力**」を持つ必要があります。これは、ユーザーが望む機能をシンプルかつ直感的に実現できることを意味します。APIが提供する機能は、ユーザーが容易に理解し、使用できるように設計されていなければなりません。

実際には、このような表現力を持つAPIを設計することは容易ではありません。API設計者は、ユーザーがどのようにAPIを使用するかを深く理解し、ユーザーの要求を先読みして適切な機能を提供する必要があります。このプロセスには、ユーザーフィードバックの収集と分析、利用パターンの観察、そして時には創造的な問題解決が必要です。表現力の高いAPIは、ユーザーが直感的に理解しやすく、より満足度の高い体験を提供します。

## Simple -シンプルであること-
良いAPI設計において重要なのは、その「**シンプルさ**」です。シンプルさとは、APIに含まれる要素（RPCやリソースなど）の数を単純に減らすことではなく、ユーザーが必要とする機能を最も直接的かつ簡単な方法で利用できるようにすることです。

シンプルさを追求する際には、一般的な機能は簡単に使えるようにしつつ、高度な機能も提供できるように設計することが大切です。つまり、APIが高度な機能を提供する場合でも、一般的なユーザーにはその複雑さが隠蔽されているべきです。

## Predictable -予測可能であること-
良いAPIは、ユーザーに予期せぬ驚きを与えることなく、「**予測可能**」でなければなりません。驚かせないAPIとは、定義や基本動作が一貫しており、ユーザーが直感的に理解できるものです。この原則は、APIの設計全体において、特に名前付けや動作パターンにおいて重要です。

一貫したフィールド名や標準メソッドなど、繰り返し出てくるパターンを持つAPIは、利用者にとって習得が容易で、効率的です。このように、よく知られ、よく定義された明確なパターンを使用することで、APIは予測可能で、全体として「より良い」APIになります。

予測可能なAPIは、利用者が自信を持って使用できるようにし、生産性を高めるために不可欠です。利用者が何を期待するかを理解し、それに応えることで、APIはより使いやすく、効果的なものになります。

# 馴染みのあるAPI設計


# デザインパターンの紹介
本セクションでは、APIのデザインパターンについて、実際のTypeScriptのソースコードを用いることで、理論だけではなく、実践に基づいた深い理解を促します。TypeScriptは多くの開発者にとって馴染み深い言語であり、APIの概念を明確に示すのに適しています。

また、APIメソッドの入出力に関する考察も行います。リクエストとレスポンスのインターフェースを使用し、メソッド名には慣例として`Request`や`Response`を接尾辞に付けます。

さらに、TypeScriptのデコレータを活用してRESTfulなAPIメソッドで実装例を示します。これは、APIがHTTPメソッドやURLにどのようにマッピングされるかを理解するのに役立ちます。

## カスタムメソッド
### 概要
カスタムメソッドは、APIの標準メソッドの範囲外で使用され、標準メソッドの厳格な要件を満たす必要がない操作に採用されます。標準メソッドが広範囲にわたるガイドラインやルールに従う必要があるのに対し、カスタムメソッドはほとんど制約がなく、状況に応じて最適な行動を取ることができます。しかし、APIの利用者はカスタムメソッドに対して標準メソッドと同様の多くの仮定を行うことができないため、API全体で一貫性を持たせることが重要です。

https://cloud.google.com/apis/design/custom_methods?hl=ja

### 対象とする問題
多くのAPIでは、標準メソッドに適合しない特定の操作を実行する必要があります。例えば、メール送信や即時の文書翻訳などは、通常のcreateやupdateメソッドで処理するには不適切です。カスタムメソッドは、これらの非標準的な操作を可能にし、APIの利便性を高めるために存在します。

### 問題点
カスタムメソッドは、適切なリソースセットがあれば標準メソッドで実現可能なことを行う手段として使用されますが、不適切なリソースレイアウトを正当化したり、過剰に使用されることでAPI設計が悪化する可能性があります。

### 実装例
カスタムメソッドは標準メソッドと似た形式で実装されますが、主な違いはHTTPリクエストの形式にあります。標準メソッドがリクエストパスとHTTPメソッドの組み合わせで操作を識別するのに対し、カスタムメソッドでは特別な書式を用いてリクエストパスに関連情報を配置します。以下はカスタムメソッドを使用してメールを送信する操作を示すTypeScriptの実装例です。

```typescript
abstract class EmailApi {
  @post("/{id=users/*emails/*}:send")
  abstract SendEmail(req: SendEmailRequest): Email;
}

interface Email {
  id: string;
  subject: string;
  content: string;
  state: string;
  deleted: boolean;
  // ...
}
```

## ロングランオペレーション（Long Running Operations, LRO）
### 概要
LROとは、時間を要する作業を指します。このような作業を行いながらも、他の作業を同時に進めたい場合、現代のプログラミング言語は非同期動作をサポートしています。これにより、時間がかかる作業をブロックせずにプログラム内で簡単に管理できます。
この機能は、作業の開始時に特定のプレースホルダーを返し、作業が完了した際にはこのプレースホルダーが結果と共に「解決」されるか、エラーが発生した場合には「拒否」されます。この仕組みを利用することで、プログラマはコールバックをプレースホルダーに登録し、結果を非同期に処理することができます。また、必要に応じて結果が返されるまで待ち、プレースホルダーが解決または拒否されるまでコードの実行を一時停止することも可能です。

https://cloud.google.com/translate/docs/advanced/long-running-operation?hl=ja

### 対象とする問題
APIが複雑な作業や大量のリソースを扱う必要がある場合、単純なAPI設計では速い動作と遅い動作の間で一貫性を保つことが難しくなります。時間がかかる作業に対しては特別な考慮が必要になります。

### 問題点
LROは、最初に理解するのが少し難しいかもしれない複雑で汎用性が高く、パラメーター化されたリソースです。LROは、他の作業を要求することによってのみ存在し、明示的に作成されるわけではありません。これは、従来のリソース作成の方法論とは異なるアプローチを提供します。

### 実装例
LROを扱うためには、Operationリソースを定義し、APIがLROを発見して管理する方法を提供する必要があります。これには、Operationオブジェクトの作成、進行状態の監視、および必要に応じて操作の一時停止、再開、キャンセルを行うメソッドの定義が含まれます。（今回は一部を実装）

```typescript
abstract class ChatRoomApi {
  @get("/{id=operations/*}")
  abstract GetOperation<ResultT, MetadataT>(req: GetOperationRequest):
    Operation<ResultT, MetadataT>;

  @post("/{id=operations/*}:cancel")
  abstract CancelOperation<ResultT, MetadataT>(req: CancelOperationRequest):
    Operation<ResultT, MetadataT>;
}

interface Operation<ResultT, MetadataT> {
  id: string;
  done: boolean;
  expireTime: Date;
  result?: ResultT | OperationError;
  metadata?: MetadataT;
}

interface OperationError {
  code: string;
  message: string;
  details?: any;
}

interface GetOperationRequest {
  id: string;
}

interface CancelOperationRequest {
  id: string;
}
```

## 再実行可能ジョブ
## シングルトンサブリソース
### 概要
シングルトンサブリソースとは、あるリソースの構成要素を単なるプロパティから、より独立性の高いエンティティへと進化させる手法です。このアプローチにおいて重要な戦略の一つは、問題のある構成要素をリソース全体と単純なプロパティの間に位置するもの、つまりハイブリッドな存在としてデザインすることです。これにより、フルリソースが提供する特定の特性や機能と、単純なプロパティが持つ他の特性や機能を兼ね備えた新たな形態を創出することが可能になります。

https://cloud.google.com/apis/design/design_patterns?hl=ja#singleton_resources

### 対象とする問題
API設計時、リソースの構成要素がプロパティに適しているにもかかわらず、通常のプロパティとして扱えない場合があります。
以下のような事例はその最たる例です。

#### サイズや複雑さ
単一の構成要素がリソース全体よりも大きく複雑になる場合、リソースから分離するべきです。例えば、大きなバイナリオブジェクトの保存では、バイナリデータをメタデータと共に保持することは少ないです。

#### セキュリティ
リソースの一部が異なるアクセス制限を必要とする場合、それをリソースから完全に分離することが重要です。例えば、従業員データのAPIでは、報酬情報が一般的な情報よりも厳格なアクセス制限を受ける可能性があります。

#### ボラティリティ
リソースの特定構成要素が通常と異なるアクセスパターンを持つ場合、頻繁に更新される要素は他と分離し、独立して更新できるようにするべきです。例えば、ライドシェアのAPIでドライバーの位置情報は頻繁に更新されますが、ナンバープレートなどの情報はそうではありません。

### 問題点
シングルトンサブリソースの設計では、リソースとそのサブリソースを同時に、アトミックに操作する方法が不可能になります。これは、特定の情報セットを親リソースから分離し、独立させることが主な目的であるため、設計上の制限として存在します。例えば、DriverLocation情報をDriverリソースの一部として扱っていた場合、特定の位置情報を持つDriverリソースを一度に作成することが可能でしたが、サブリソースを分離することにより、このような同時操作が行えなくなります。

### 実装例
ライドシェアリングサービスのAPIでのシングルトンサブリソースの実装例を示します。
以下のコードスニペットでは、`RideSharingApi` 抽象クラスを通じて、ドライバー情報と位置情報の取得及び更新を行う方法を示しています。具体的には、ドライバーの詳細情報を取得・更新するエンドポイントと、ドライバーの現在位置を取得・更新するエンドポイントが提供されています。

```typescript
abstract class RideSharingApi {
  @get("/{id=drivers/*}")
  abstract GetDriver(req: GetDriverRequest): Driver;

  @patch("/{resource.id=drivers/*}")
  abstract UpdateDriver(req: UpdateDriverRequest): Driver;

  @get("/{id=drivers/*/location}")
  abstract GetDriverLocation(req: GetDriverLocationRequest): DriverLocation;

  @patch("/{resource.id=drivers/*/location}")
  abstract UpdateDriverLocation(req: UpdateDriverLocationRequest): DriverLocation;
}

interface Driver {
  id: string;
  name: string;
  licensePlate: string;
}

interface DriverLocation {
  id: string;
  lat: number;
  long: number;
  updateTime: Date;
}

interface GetDriverLocationRequest {
  id: string;
}

interface UpdateDriverLocationRequest {
  resource: DriverLocation;
  fieldMask: FieldMask;
}
```

# おわりに
