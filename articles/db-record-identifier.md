---
title: "他のレコードと違う存在になりたいレコードへ"
emoji: "🤡"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["DB", "レコード", "識別子"]
published: false
---

# TL;DR

# はじめに

データーベースにおいて、データを一意に識別する手段は、システムの信頼性と効率の基盤となります。多くのアプリケーションフレームワークでは、シンプルで実績のある「Auto Increment」方式をデフォルトの識別子として採用しています。これは、シーケンシャルに増加する数値を使い、データベースの各レコードにユニークなIDを割り振る方法です。この単純さが、特に単一のデータベースサーバーを用いる場合や小規模なアプリケーションにおいては、その強みとなっています。

しかし、現代のアプリケーションは、単純なブログやウェブショップを超えて、分散システム、マイクロサービスアーキテクチャ、クラウドベースのスケーラビリティを要求されることが増えています。このような複雑なシステムでは、Auto IncrementのIDが持つ限界が顕著になり始めます。スケールアウトや複数の書き込みノードを持つ環境では、IDの衝突を避けるための追加的な工夫が必要となり、その管理が煩雑になることがあります。また、IDを予測可能なシーケンスにすることは、セキュリティー上のリスクを招く可能性もあります。

これらの課題を解決するために、UUID、ULID、Snowflakeのような新しい形式の識別子が提案されてきました。これらの技術は、ユニークさ、スケーラビリティ、生成の予測不可能性など、特定の利点を提供し、より要求の厳しい現代のアプリケーションのニーズに応えることを目的としています。本記事では、これらの識別子がどのように機能し、それぞれがどのような状況で最適であるかを解き明かしていきます。

# データ識別子

## Auto Increment

| id  | name  |
| --- | ----- |
| 1   | Alice |
| 2   | Bob   |
| 3   | Peter |
| 4   | Tom   |

### 特徴

### Pros

### Cons

## UUID

| id                                   | name  |
| ------------------------------------ | ----- |
| 550e8400-e29b-41d4-a716-446655440000 | Alice |
| 123e4567-e89b-12d3-a456-426614174000 | Bob   |
| 0c74f13f-fa83-4c48-9b33-689fed9a34b7 | Peter |
| 5f9c7df8-3d59-4846-99fe-c4518e82c86f | Tom   |

### 特徴

### Pros

### Cons

## ULID

| id                         | name  |
| -------------------------- | ----- |
| 01ARZ3NDEKTSV4RRFFQ69G5FAV | Alice |
| 01ARYZ6S41TSV4RRFFQ69G5FAV | Bob   |
| 01AS3YPYXJTSV4RRFFQ69G5FAV | Peter |
| 01B2M2Y8JPTSV4RRFFQ69G5FAV | Tom   |

### 特徴

### Pros

### Cons

## Snowflake

| id                  | name  |
| ------------------- | ----- |
| 1382971839180339201 | Alice |
| 1382971839180339202 | Bob   |
| 1382971839180339203 | Peter |
| 1382971839180339204 | Tom   |

### 特徴

### Pros

### Cons

# データ識別子の比較

# ユースケース

# おわりに

# 参考文献
